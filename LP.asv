%simplex

% 

f   = [-3; -5];           % note: linprog does minimization ⇒ negate objective
A   = [2 1; 1 2];
b   = [8; 8];

[x, index, y] = simplex(A, b, f); 

y'

function [x, index, y] = simplex(B, b, f)

n = numel(b);
I = eye(n);
A = [B, I]; % builds the constriant with slack variables
c = [f; zeros(n, 1)];
[n, m] = size(A);
index = [n+1:m]; % gets the starting index values
non_index = [1:n]; % stores the locked variables

for i = 1:10 % starts the indexing loop
    A_b = A(:, index); % gets the first solution
    A_v = A(:, non_index);
    c_v = c(non_index);
    c_b = c(index); 
    y = A_b'\c_b; % calculates the new y
    r_v = c_v' - y'*A_v;

    if r_v > 0 break; end

    [minimum, idx_add] = min(r_v); % gets the loosening value
    a_k = A_v(:, idx_add);
    a_bar = A_b\a_k; %calculates the a_bar
    b_bar = A_b\b; 
    t = b_bar./a_bar;
    [val, idx_remove] = mint(t); %tittar på dem indexen som faktiskt är med
    %now we are ready to switch in this case
    idx1 = index(idx_remove);
    idx2 = non_index(idx_add);
    index;
    non_index;
    
    index(idx_remove) = idx2;
    non_index(idx_add) = idx1;

end

x = A_b\b;
y = b'\(c(index)' * x);

% when we have the simplex we can solve the dual in this case


end 




function [val, idx] = mint(t)
n = numel(t);
val = t(1);
idx = 1;
for i = 1:n
    if t(i) < val && t(i) >= 0
        val = t(i);
        idx = i;
    end

end
end